---
title: "Import of Stage 1 Field Transect data for Boundary from Avenza PDF maps schema and consolidate"
subtitle: "by Gen Perkins"
date: "10/06/2020"
output: html_document
---

```{r global_options, include=FALSE }
require(knitr)

```


```{r setup, include=FALSE}

library(tidyverse)
library(raster)
library(fasterize)
library(sf)
library(clhs)
library(tools)
library(stringr)
library(lwgeom)
library(dplyr)
library(ranger)
library(foreach)
library(scales)
library(stringr)

# if Velox is not installed previously
#library(devtools)
#install_github("hunzikp/velox")

```

## Introduction

This script contains functionality for the import data collected by Avenza following field collection of triangular paired transects (Stage 1 and 2 Study Design). This script performs several steps:

1. Import transects from shapefiles or geopackage exported from Avenza PDF maps. Consolidate various years of data. 

2. Converts data to vector triangles (using point to point). Specifically this converts the points to lines (or track log to lines), add the field sample data as attributes to the line. 

In Boundary - data was collected over various years by differnt groups, as the schemas evolved over time the data needs to be treated differently for each year/ group collected. 


## Boundary training points types
#s1 - transects (line)
  - 2019 - BC staff
  - 2020 - ECORA 
  - 2020 - BC Staff (ESSF)
  - 2021 - ECORA 

#s2 - transects (line)
  - 2020 - BC staff (MS, IDF)


## 1. Set up folder structure for Stage 1 sampling 

```{r set up folder structure }

AOI <- "BoundaryTSA"

res <- 2.5

AOI_dir <- file.path(".", paste0(AOI,"_AOI"))
cov_dir <- file.path(AOI_dir, "1_map_inputs", "covariates")

##stage 1
trans_layout <- file.path(AOI_dir, "2_sample_design", "stage1_StudyDesign", "transect_layout")
trans_data <- file.path(AOI_dir, "2_sample_design", "stage1_StudyDesign", "transect_data") 

##stage 2
trans_layout_s2 <- file.path(AOI_dir, "2_sample_design", "stage2_StudyDesign", "transect_layout")
trans_data_s2 <- file.path(AOI_dir, "2_sample_design", "stage2_StudyDesign", "transect_data") 


output_pnts_dir <- file.path(AOI_dir, "2_sample_design", "stage1_StudyDesign", "training_pts")

output_pnts_dir_s2 <- file.path(AOI_dir, "2_sample_design", "stage2_StudyDesign", "training_pts")

map.key  <- read.csv(file.path(AOI_dir, "_MapUnitLegend", 
                                 paste0(AOI, "_MapUnitLegend.csv")), 
                       stringsAsFactor = FALSE)

#res_folder <- paste0(res, "m")

if(!dir.exists(output_pnts_dir)) dir.create(output_pnts_dir, recursive = TRUE)

```

Setup functions 

1. extend_lines function will extend lines in order for one line to fully intersect another line. This is only used when the track log is selected for sampling. It is contained within the "process_track".

2. process_track function will separate the tracklog based on the given point data. Some refinement required (see [issue](https://github.com/bcgov-c/BEC_DevExchange_Work/issues/21).


```{r Functions}

source(here::here('_functions', 'extend_lines.R'))
source(here::here('_functions', 'make_lines.R'))
source(here::here('_functions', 'transect_sample.R'))
source(here::here('_functions', 'multiline_to_line.R'))

```


## 1) Import and clean Avenza field transect data

1. Import transects from shape files or geopackages exported from Avenza PDF maps. The shape files contain all data collected under the schema and so generally contain all transects collected to date on a single tablet. Need to separate using the original study design transect triangles.


```{r import base files to run analysis, tidy = TRUE, warning=FALSE}

trans <- list.files(trans_layout, pattern = ".gpkg$", full.names = TRUE, recursive = FALSE)

transect_layout <- foreach(x = trans, .combine = rbind) %do% {
  #x <- trans[1]
  clhs_layers <- st_layers(x)
  lines <- which(clhs_layers[["geomtype"]] %in% c("Line String", "Multi Line String"))
  if(length(lines)) {
    transects <- foreach(y = clhs_layers$name[lines], .combine = rbind) %do% {
      transect <- st_read(x, y, quiet = TRUE) %>% 
        rename_all(recode, geom = "geometry") %>% 
        rename_all(.funs = tolower) %>%
        dplyr::select(id) %>% 
        mutate(id = as.character(id)) %>% 
        st_transform(3005)
    }
  } 
} #%>% dplyr::rename(ID = id)


transect_layout <- transect_layout %>% mutate(id = gsub("_total","", id)) %>%
  distinct()

transect_layout_buf <- st_buffer(transect_layout, 10)

st_write(transect_layout, file.path(output_pnts_dir, "transect_layout_s1.gpkg"), delete_layer = TRUE)


```


2. Connect the placemarks waypoints into a traverse using the running number name assigned by PDF maps

The following chunk creates some basic folders and loads in data that will be used across all sampling types (a raster template and the original CLHS transects).


```{r prepare raw data (unzip data and split into points and lines)}
## prepare point data sets from each year and type: 

# 2019 dataset: extract point data
yr = "2019"

poc_column <- "x6pointtype"
mapunit1_column <- "x2mapunit1"
mapunit2_column <- "x4mapunit2"
observer_column <- "x1observer"
transition_column <- "x3transitio"
comment_column <- "x5comments"

shp <- list.files(file.path(trans_data,yr), pattern = ".shp", full.names = TRUE)
tracks <- list.files(file.path(trans_data,yr), pattern = "\\(1\\).shp", full.names = TRUE)
points <- shp[!shp %in% tracks]


all_points <- foreach(x = points, .combine = rbind) %do% {
  #x <- points[1]
    print(x)
      # when all the points are consolidated into a single geopackage 
     points_read <- st_read(x, quiet = TRUE) %>%
     st_transform(3005) %>% 
     st_zm() %>% 
     rename_all(.funs = tolower) %>%
     mutate(mapunit1 = UQ(rlang::sym(mapunit1_column)),
            mapunit2 = UQ(rlang::sym(mapunit2_column)),
            point_type  = UQ(rlang::sym(poc_column)),
            observer =  UQ(rlang::sym(observer_column)), 
            transition = UQ(rlang::sym(transition_column)),
            comments = UQ(rlang::sym(comment_column))) %>%
     st_join(., transect_layout_buf, join = st_intersects) %>%
     rename_all(.funs = tolower) %>%
     rename(transect_id = id)
  
     if("name" %in% names(points_read)){
       points_read <- points_read %>%
         mutate(order = as.numeric(gsub("Placemark ", "", name)))
     }
     # } else {
     #   
     #   points_read <- points_read %>%
     #     mutate(name = seq(1, length(mapunit1),1))
     # }
    points_read <- points_read %>%
     dplyr::select(order, mapunit1, mapunit2, point_type, transect_id, observer, transition, comments) %>%
     group_by(transect_id) %>%
     arrange(as.numeric(order), by_group = TRUE) %>%
     ungroup() 

} %>% 
  distinct(., .keep_all = TRUE) 


all_points_2019 <- all_points %>% 
rename(geom = geometry)

#xx <- all_points_2019 %>%
#  group_by(transect_id) %>%
#  summarise(cound = n())


st_write(all_points_2019, file.path(output_pnts_dir, "s1_transect_points_raw_2019.gpkg"), delete_layer = TRUE)
# 
# all_points<- st_read(file.path(output_pnts_dir, "s1_transect_points_raw_2019.gpkg"))


```

Import data from 2020 Ecora: 

```{r}

# import Ecora point data from 2020. 

yr = "2020_ecora"
poc_column <- "f03_pt_type"
mapunit1_column <- "f04_mapunit1"
mapunit2_column <- "f06_mapunit2"
observer_column <- "f02_observer"
transition_column <- "f05_transition"
comment_column <- "f09_comments"
order_column <- "f11_order"

points <- list.files(file.path(trans_data, yr), pattern = ".gpkg$|.shp$", full.names = TRUE)

# for ecora 2020 data - all data supplied in two geopackages so need to split these to multiple geopackges 

indiv_files = file.path(trans_data, yr, "single_gpkgs")

if(!dir.exists(indiv_files)) dir.create(indiv_files, recursive = TRUE)

points2 <- list.files(indiv_files, pattern = ".gpkg$", full.names = TRUE)#[points_index]

all_points20 <- foreach(x = points2, .combine = rbind) %do% {
  #x <- points2[6]
 print(x)
     # when all the points are consolidated into a single geopackage 
     points_read <- st_read(x, quiet = TRUE) %>%
     st_transform(3005) %>% 
     st_zm() %>% 
     rename_all(.funs = tolower) %>%
     mutate(mapunit1 = UQ(rlang::sym(mapunit1_column)),
            mapunit2 = UQ(rlang::sym(mapunit2_column)),
            point_type  = UQ(rlang::sym(poc_column)),
            observer =  UQ(rlang::sym(observer_column)),
            transition = UQ(rlang::sym(transition_column)),
            comments = UQ(rlang::sym(comment_column)))
          
     if("f11_order" %in% names(points_read)){
        
       points_read <- points_read %>%
         mutate(order = f11_order)

     } else {
       
       points_read <- points_read %>%
         mutate(order = seq(1, length(mapunit1),1))
     }
     
     points_read <- points_read %>%
       st_join(., transect_layout_buf, join = st_intersects) %>%    
       distinct(., .keep_all = TRUE) %>%
       rename_all(.funs = tolower) %>%
       dplyr::rename(transect_id = id) %>%
       dplyr::select(mapunit1, mapunit2, point_type, transect_id, observer, transition, comments, order) %>%
       group_by(transect_id) %>%
       arrange(order, by_group = TRUE)%>%
       ungroup()
               
} %>% 
  distinct(., .keep_all = TRUE)  


st_write(all_points20, file.path(output_pnts_dir, "s1_transect_points_raw_2020.gpkg"), delete_layer = TRUE)

```

# 2021 Ecora dataset (stage 1)
```{r}

# import Ecora point data from 2021

yr = "2021_ecora"

poc_column <- "x03_pt_type"
mapunit1_column <- "x04_mapunit"
mapunit2_column <- "x06_mapunit"
observer_column <- "x02_observe"
transition_column <- "x05_transit"
comment_column <- "x09_comment"


#points <- list.files(file.path(trans_data, yr), pattern = ".gpkg$|.shp$", full.names = TRUE)

points <- list.files(file.path(trans_data), pattern = "_edit.gpkg$", full.names = TRUE, recursive = TRUE)


all_points21 <- foreach(x = points, .combine = rbind) %do% {
  x <- points[1]
  print(x)
      # when all the points are consolidated into a single geopackage 
     points_read <- st_read(x, quiet = TRUE) %>%
     st_transform(3005) %>% 
     st_zm() %>% 
     rename_all(.funs = tolower) %>%
     mutate(mapunit1 = UQ(rlang::sym(mapunit1_column)),
            mapunit2 = UQ(rlang::sym(mapunit2_column)),
            point_type  = UQ(rlang::sym(poc_column)),
            observer =  UQ(rlang::sym(observer_column)), 
            transition = UQ(rlang::sym(transition_column)),
            comments = UQ(rlang::sym(comment_column))) %>%
     st_join(., transect_layout_buf, join = st_intersects) %>%
     rename_all(.funs = tolower) %>%
     rename(transect_id = id)
  
     if("name" %in% names(points_read)){
       points_read <- points_read %>%
         mutate(order = as.numeric(gsub("Placemark ", "", name)))
     }

      points_read <- points_read %>%
     dplyr::select(order, mapunit1, mapunit2, point_type, transect_id, observer, transition, comments) %>%
     group_by(transect_id) %>%
     arrange(as.numeric(order), by_group = TRUE) %>%
     ungroup() 

} %>% 
  distinct(., .keep_all = TRUE) 

st_write(all_points21, file.path(output_pnts_dir, "s1_transect_points_raw_2021.gpkg"), delete_layer = TRUE)


```


```{r}

# add 2020 BC gov data - Essf 

yr = "2020_bcgov"
poc_column <- "x03_pt_type"
mapunit1_column <- "x04_mapunit"
mapunit2_column <- "x06_mapunit"
observer_column <- "x02_observe"
transition_column <- "x05_transit"
comment_column <- "x09_comment"

shp <- list.files(file.path(trans_data,yr), pattern = ".shp", full.names = TRUE, recursive = TRUE)
tracks <- list.files(file.path(trans_data,yr), pattern = "\\(1\\).shp", full.names = TRUE, recursive = TRUE)

points <- shp[!shp %in% tracks]

all_points_2020bc <- foreach(x = points, .combine = rbind) %do% {
  #x <- points[1]
    print(x)
      # when all the points are consolidated into a single geopackage 
     points_read <- st_read(x, quiet = TRUE) %>%
     st_transform(3005) %>% 
     st_zm() %>% 
     rename_all(.funs = tolower) %>%
     mutate(mapunit1 = UQ(rlang::sym(mapunit1_column)),
            mapunit2 = UQ(rlang::sym(mapunit2_column)),
            point_type  = UQ(rlang::sym(poc_column)),
            observer =  UQ(rlang::sym(observer_column)), 
            transition = UQ(rlang::sym(transition_column)),
            comments = UQ(rlang::sym(comment_column))) %>%
     st_join(., transect_layout_buf, join = st_intersects) %>%
     rename_all(.funs = tolower) %>%
     rename(transect_id = id)
  
     if("name" %in% names(points_read)){
       points_read <- points_read %>%
         mutate(order = as.numeric(gsub("Placemark ", "", name)))
     }
     # } else {
     #   
     #   points_read <- points_read %>%
     #     mutate(name = seq(1, length(mapunit1),1))
     # }
    points_read <- points_read %>%
     dplyr::select(order, mapunit1, mapunit2, point_type, transect_id, observer, transition, comments) %>%
     group_by(transect_id) %>%
     arrange(as.numeric(order), by_group = TRUE) %>%
     ungroup() 

} %>% 
  distinct(., .keep_all = TRUE) 

all_points_2020bc <- all_points_2020bc %>% 
rename(geom = geometry)

all_points_2020bc


st_write(all_points_2020bc, file.path(output_pnts_dir, "s1_transect_points_raw_2020bc.gpkg"), delete_layer = TRUE)


```

# add all satge 1 data together and cross reference calls to map unit key

```{r}
# bind all point datasets together
points_total <- bind_rows(all_points_2019, all_points20)
points_total = bind_rows(points_total, all_points_2020bc)
points_total = bind_rows(points_total, all_points21)


# catergorise data types:
  
points <- points_total %>%
  mutate(data_type = ifelse(is.na(transect_id), "incidental", "s1"))

# match to the baseunit key using mapunit legend & format observer column
points_final <- format_mapunit_names(points, map.key)
points_final <- fill_observer(points_final)

# covert to lines 
processed_transects <- make_lines(GPSPoints = points_final, 
                                  #GPSTracks = all_tracks,
                                  Transects = transect_layout_buf, 
                                  method = "pts2lines", #"tracklog",  
                                  tBuffer = 20, PROJ = 3005) %>%
  mutate(mapunit1 = (trimws(mapunit1)),
         mapunit2 = (trimws(mapunit2))) %>%
  mutate(mapunit12 = paste0(mapunit1,"_", mapunit2)) %>%
  mutate(mapunit12 = gsub("_NA","", mapunit12)) %>%
  mutate(mapunit12 = gsub("_$","", mapunit12)) %>%
  dplyr::select(-TID, -ID)

st_write(processed_transects,  file.path(output_pnts_dir, "proc_s1_transects.gpkg"), 
         delete_layer = TRUE)

#processed_transects <- st_read(file.path(output_pnts_dir, "proc_s1_transects.shp"))

st_write(points_final, file.path(output_pnts_dir, "s1_pts.gpkg"), delete_layer = TRUE)

```


# summarise and fix slices if needed: 


```{r, echo = FALSE}

processed_transects <- st_read(file.path(output_pnts_dir, "proc_s1_transects.gpkg"))

points_final_edit <- st_read(file.path(output_pnts_dir, "s1_pts.gpkg"))

#head(points_final)

#pt_sum <- points_final_edit %>%
#  group_by(transect_id) %>%
#  summarise(count = n())

#write.csv(pt_sum, file.path(output_pnts_dir, "transect_boundary_summary.csv"))


# ESSFdc1 - 3 slices  (10 transect pairs, 20 transects)
    # slice 1 =  3 sites) 
    # slice 2 =  2 sites 
    # slice 3 =  5 sites 

# ESSFdc2 - 2 slices (9 transect pairs, 18 transect 
    # slice 1 = 5 sites
    # slice 2 = 4 sites ) # need to fix the naming for these (see below)


#        transect_id == "ESSFdc2_s1_1_cLHS" ~ "ESSFdc2_2.1_6_cLHS",
#        transect_id ==  "ESSFdc2_s1_1_N"  ~  "ESSFdc2_2.1_6_N",
#        transect_id == "ESSFdc2_s1_5_cLHS" ~ "ESSFdc2_2.2_7_cLHS",
#        transect_id == "ESSFdc2_s1_5_N" ~    "ESSFdc2_2.2_7_cLHS",
#        transect_id == "ESSFdc2_s1_7_cLHS" ~ "ESSFdc2_2.3_8_cLHS",
#        transect_id ==  "ESSFdc2_s1_7_S"  ~  "ESSFdc2_2.3_8_cLHS",
    

# ESSFmh - 6 slices (25 transect pairs, 50 transects)
   # slice 1 - 4 sites
   # slice 2 - 4
   # slice 3 - 4 
   # slice 4 - 4
   # slice 5 - 5
   # slice 6  - 4 sites 

# ICHmd1 - 3 slices (10 transect pairs, 20 transect )
    # slice 1 - 4 sites
    # slice 2 - 3 sites
    # slice 3 - 3 sites 

# ICH mk1 - 2 slices ( 10 transect pairs, 20 transsects)
    # slice 1 - 5 site
    # slice 2 - 5 site

# ICH xw (combined xw and xwa) (10 transect pairs, 20 transsects)
   # slice 1 - 5 sites
   # slice 2 - 5 sites 

# adjusted the BEC layer to include both the ICH xw and ICH xwa in the same map. 


# ICHmw5 ( 6 slices, 25 sites, 50 transects)
  # slice 1 - 4 sites
   # slice 2 - 5
   # slice 3 - 4 
   # slice 4 - 4
   # slice 5 - 4
   # slice 6 - 4 sites 

# Idf dh1 ( 1 slice) 5 transect pairs, 10 transect 
    # slice 1 - 5 site

# IDFdm1 ( 5 slice , 23 sites - 44 transects)
   # slice 1 - 5 sites (2019)
   # slice 2 - 4.5 sites (2019)
   # slice 3 - 4.5 
   # slice 4 - 4 sites
   # slice 5 - 4 sites
  # sampled in 2019 and 2020 (need to relable for 2020 sites to avoic confusion)

    # changed the names of transect id for 2020 dataset:

#    IDFdm1_2.5.10_cLHS (2020) changed to IDFdm1_1.3_3_cLHS
#    IDFdm1_2.1.6_cLHS (2020) changed to IDFdm1_1.2.2_cLHS
#    IDFdm1_1.4.4_SW (2020) changed to IDFdm1_5.4.24_cLHS
#    IDFdm1_1.2.2_SW (2020) changed to IDFdm1_5.2.22_cLHS
#    IDFdm1_1.5.5_SW (2020) changed to IDFdm1_5.3.23_cLHS
#    IDFdm1_4.4.9_SW (2020) changed to IDFdm1_5.5_25_cLHS


# MSdm1

   # slice 1 - 5
   # slice 2 - 5
  # slice 3 - 5
   # slice 4 - 5
   # slice 5 - 5 

# sampled in 2019 and 2020 (need to relable for 2020 sites to avoic confusion)
# changed to transect id for 2019 sites to update, 

#  MSdm1_1.3_3    (2019) change to MSdm1_1.5_5
#  Msdm1_2.1_6    (2019) change to MSdm1_2.2_7
#  MSdm1_3.1.11   (2019) change to MSdm1_3.5_15
#  MSdm1_3.2.12   (2019) change to MSdm1_2.3_8
#  MSdm1_4.1_16   (2019) change to MSdm1_4.5_20
#  MSdm1_4.2_17   (2019) change to MSdm1_5.1_21






# need to adjust points, transects and processed

#points_final_edit <- points_final %>% 

#      mutate(tid = tolower(gsub("_[[:alpha:]].*","", transect_id)))
 

```




Import stage 2 data collection

```{r}

trans_s2 <- list.files(trans_layout_s2, pattern = ".gpkg$", full.names = TRUE, recursive = FALSE)

transect_layout_s2 <- foreach(x = trans_s2, .combine = rbind) %do% {
  clhs_layers <- st_layers(x)
  lines <- which(clhs_layers[["geomtype"]] %in% c("Line String", "Multi Line String"))
  if(length(lines)) {
    transects <- foreach(y = clhs_layers$name[lines], .combine = rbind) %do% {
      transect <- st_read(x, y, quiet = TRUE) %>% 
        rename_all(recode, geom = "geometry") %>% 
        rename_all(.funs = tolower) %>%
        dplyr::select(id) %>% 
        mutate(id = as.character(id)) %>% 
        st_transform(3005)
    }
  } 
} #%>% dplyr::rename(ID = id)

transect_layout_buf_s2 <- st_buffer(transect_layout_s2, 10)

st_write(transect_layout_s2, file.path(output_pnts_dir_s2, paste0("transect_layout_s2.gpkg")), 
        delete_layer = TRUE)

poc_column <- "x03_pt_type"
mapunit1_column <- "x04_mapunit"
mapunit2_column <- "x06_mapunit"
observer_column <- "x02_observe"
transition_column <- "x05_transit"
comment_column <- "x09_comment"

shp <- list.files(file.path(trans_data_s2), pattern = ".shp", full.names = TRUE, recursive = TRUE)
tracks <- list.files(file.path(trans_data_s2), pattern = "\\(1\\).shp", full.names = TRUE, recursive = TRUE)

points_s2 <- shp[!shp %in% tracks]

all_points_s2 <- foreach(x = points_s2, .combine = rbind) %do% {
 # x <- points[5]
    print(x)
      # when all the points are consolidated into a single geopackage 
     points_read <- st_read(x, quiet = TRUE) %>%
     st_transform(3005) %>% 
     st_zm() %>% 
     rename_all(.funs = tolower) %>%
     mutate(mapunit1 = UQ(rlang::sym(mapunit1_column)),
            mapunit2 = UQ(rlang::sym(mapunit2_column)),
            point_type  = UQ(rlang::sym(poc_column)),
            observer =  UQ(rlang::sym(observer_column)), 
            transition = UQ(rlang::sym(transition_column)),
            comments = UQ(rlang::sym(comment_column))) %>%
     st_join(., transect_layout_buf_s2, join = st_intersects) %>%
     rename_all(.funs = tolower) %>%
     rename(transect_id = id)
  
     if("name" %in% names(points_read)){
       points_read <- points_read %>%
         mutate(order = as.numeric(gsub("Placemark ", "", name)))
     }
     # } else {
     #   
     #   points_read <- points_read %>%
     #     mutate(name = seq(1, length(mapunit1),1))
     # }
    points_read <- points_read %>%
     dplyr::select(order, mapunit1, mapunit2, point_type, transect_id, observer, transition, comments) %>%
     group_by(transect_id) %>%
     arrange(as.numeric(order), by_group = TRUE) %>%
     ungroup() 

} %>% 
  distinct(., .keep_all = TRUE) 

points_s2 <- all_points_s2 %>% 
  rename(geom = geometry) %>%
  st_as_sf(., sf_column_name = "geom") %>%
  mutate(data_type = ifelse(is.na(transect_id), "incidental", "s2"))

points_s2 <- fill_observer(points_s2)
  
points_final <- format_mapunit_names(points_s2, map.key)
 
# covert to lines 
processed_transects <- make_lines(GPSPoints = points_final, 
                                  #GPSTracks = all_tracks,
                                  Transects = transect_layout_s2, 
                                  method = "pts2lines", #"tracklog",  
                                  tBuffer = 20, PROJ = 3005) %>%
  mutate(mapunit1 = (trimws(mapunit1)),
         mapunit2 = (trimws(mapunit2))) %>%
  mutate(mapunit12 = paste0(mapunit1,"_", mapunit2)) %>%
  mutate(mapunit12 = gsub("_NA","", mapunit12)) %>%
  mutate(mapunit12 = gsub("_$","", mapunit12)) %>%
  dplyr::select(-TID, -ID)

st_write(processed_transects,  file.path(output_pnts_dir_s2, "proc_s2_transects.gpkg"), 
         delete_layer = TRUE)

st_write(points_final, file.path(output_pnts_dir_s2, "s2_pts.gpkg"), delete_layer = TRUE)

```



# next step - subset point data using a variety of methods and attribue data 


# go to script = 04c_Training_Pt_subsample.Rmd

